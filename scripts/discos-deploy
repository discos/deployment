#!/usr/bin/env python
"""Some command line examples:

  $ discos-deploy discos:development
  $ discos-deploy discos:srt
  $ discos-deploy manager:medicina --branch master
  $ discos-deploy manager:noto --branch discos1.0-rc02
  $ discos-deploy console:development --no-vagrant
  $ discos-deploy manager:development --branch master --station srt
"""

import sys
import subprocess
import os
import argparse
import getpass
import deployment

STATIONS = { 'srt': 'SRT', 'medicina': 'Medicina', 'noto': 'Noto' }
ENVIRONMENTS = deployment.getInventories()

inventories = {}
systems = []
for env in ENVIRONMENTS:
    h, g, c = deployment.parseInventory(env)
    inventories[env] = {}
    inventories[env]['hosts'] = h
    inventories[env]['groups'] = g
    inventories[env]['clusters'] = c

    for cluster in c:
        systems.append(f'{cluster}:{env}')

parser = argparse.ArgumentParser(
    description=f'Make a DISCOS environment. {__doc__}',
    formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument(
    'system',
    help='{systems[0]}, {systems[1]}, ...'
)
parser.add_argument(
    '-s',
    '--station',
    choices=STATIONS.keys(),
    default=None,
    help='the desired station'
)
group = parser.add_mutually_exclusive_group()
group.add_argument(
    '-b',
    '--branch',
    help='the desired DISCOS branch or tag to be deployed on the machines'
)
parser.add_argument(
    '--no-vagrant',
    action='store_true',
    help='forces the process to not use Vagrant with development machines'
)
parser.add_argument(
    '--sim',
    action='store_true',
    help='only print the final Ansible command without executing it'
)
args = parser.parse_args()

# Check if the system cluster:environment exists
if args.system.count(':') != 1:
    e = ENVIRONMENTS[-1]  # A random environment
    c = inventories[e]['clusters'][-1]  # A random cluster
    deployment.error(
        (
            f'You must specify an available system.\n'
            f'e.g. if the cluster is "{c}" '
            f'and the environment is "{e}",\n'
            f'the system is "{c}:{e}", and the command will be:'
            f'\n\n  $ discos-deploy {c}:{e}.\n\n'
        ),
        choices=systems,
        name='system'
    )
else:
    cluster_arg, env_arg = args.system.split(':')
    if env_arg in ENVIRONMENTS:
        allowed_clusters = inventories[env_arg]['clusters']
        c = allowed_clusters[-1]  # A random cluster
        # wrong_cluster:right_env
        if cluster_arg not in allowed_clusters:
            msg = f'Cluster "{cluster_arg}" not found '
            msg += f'in the "{env_arg}" environment.\n'
            deployment.error(
                msg,
                allowed_clusters,
                name=f'cluster (in {env_arg})'
            )
    else:
        all_clusters = []
        for env in ENVIRONMENTS:
            for cluster in inventories[env]['clusters']:
                if cluster not in all_clusters:
                    all_clusters.append(cluster)
        # right_cluster:wrong_env
        if cluster_arg in all_clusters:
            deployment.error(
                f'Environment "{env_arg}" not found in {ENVIRONMENTS}.\n'
                f'Please use a correct cluster:environment combination, '
                f'like:\n{systems[0]}, {systems[-1]}, {systems[-2]}, ...'
            )
        # wrong_cluster:wrong_env
        if cluster_arg not in all_clusters:
            deployment.error(
                f'System "{cluster_arg}:{env_arg}" not recognized.\n',
                systems,
                name='system'
            )

inventory = os.path.join(deployment.INVENTORIES_DIR, env_arg)
playbook = os.path.join(deployment.ANSIBLE_DIR, env_arg + '.yml')

# Machines to provision in the current process
current_machines = []
if cluster_arg in inventories[env_arg]['groups']:
    current_machines = inventories[env_arg]['groups'][cluster_arg]
else:
    current_machines.append(cluster_arg)

deploy_vars = []
if args.branch:
    if env_arg == 'development':
        if not args.station:
            deployment.error(
                "When deploying onto 'development' environment, "
                + "'--station' argument must be specified."
            )
        elif args.station not in STATIONS.keys():
            deployment.error(f'Unknown station `{args.station}`.')
        deploy_vars.append('cdb=test')
        deploy_vars.append(f'station={STATIONS[args.station]}')
    else:
        if args.station and args.station != env_arg:
            deployment.error(
                f"With '{env_arg}' environment, '--station' "
                f"argument defaults to '{env_arg}', "
                f'you cannot specify a different station.'
            )
        deploy_vars.append('cdb=telescope')
    if args.branch:
        deploy_vars.append(f'branch={args.branch}')

ips = {}
for machine in current_machines:
    # Get the ip of each current machine
    ips[machine] = inventories[env_arg]['hosts'][machine]['ip']

# Check machine availability
for machine in current_machines:
    if env_arg == 'development' and not args.no_vagrant:
        if not args.sim:
            if not deployment.ping(ips[machine]):
                # Create/bring up virtual machines
                code = deployment.createVm(machine)
                if code:
                    deployment.error(
                        f'Encountered some problems while starting '
                        f'machine {machine}.',
                        code=code
                    )
        else:
            print(f'Starting machine {machine}....done.')
    elif not args.sim:
        if not deployment.ping(ips[machine]):
            deployment.error(
                f'Machine {machine} not reachable.'
                + ' Check your network and ssh configurations and retry.'
            )

if not args.sim:
    # Generate the RSA key pair if needed
    deployment.generateRSAKey()
    # Add the IPs to known_hosts
    deployment.updateKnownHosts(ips.values())

# Ask for root password
if not args.sim:
    os.environ['SSH_ASKPASS'] = os.path.join(
        os.path.dirname(os.path.abspath(sys.argv[0])),
        'discos-askpass'
    )
    for machine in current_machines:
        ip = inventories[env_arg]['hosts'][machine]['ip']
        if not deployment.sshLogin(ip):
            # Cannot authenticate, we need to exchange the public key
            os.environ['DEPLOY_PASSWORD'] = getpass.getpass(
                f"Type the password for user 'root' on machine {machine}: "
            )
            os.unsetenv('DEPLOY_PASSWORD')
            deployment.authorizeKey(ip)
            if not deployment.sshLogin(ip):
                deployment.error(
                    f'Cannot authenticate to machine {machine}, '
                    f'try again with the correct password.'
                )

# Call ansible
ansible_cmd = [
    'ansible-playbook', playbook,
    '--inventory-file', inventory,
    '--limit', cluster_arg
]

extra_vars = []
if env_arg != 'development':
    extra_vars.append(f'station={STATIONS[env_arg]}')

print('\nProvisioning with Ansible...')
if args.sim:
    print(' '.join(ansible_cmd) + (' --extra-vars ' + ' '.join(extra_vars) if extra_vars else ''))
else:
    subprocess.call(ansible_cmd + (['--extra-vars'] + extra_vars if extra_vars else []))

if deploy_vars:
    extra_vars += deploy_vars
    print('\nDeploying DISCOS with Ansible...')
    if args.sim:
        print(' '.join(ansible_cmd) + ' --extra-vars ' + ' '.join(extra_vars))
    else:
        subprocess.call(ansible_cmd + ['--extra-vars'] + extra_vars)
