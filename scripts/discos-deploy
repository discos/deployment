#! /usr/bin/env python
"""Some command line examples:

  $ discos-deploy discos:development
  $ discos-deploy discos:srt
  $ discos-deploy manager:medicina --deploy master
  $ discos-deploy as:development
  $ discos-deploy manager:development --deploy master --station srt
"""

from __future__ import print_function
import os
import sys
import argparse
import subprocess
import getpass
import paramiko

ROOT_DIR = os.path.dirname(os.path.realpath(__file__)).rsplit('/', 1)[0]
STATIONS = ('srt', 'medicina', 'noto')
ANSIBLE_DIR = os.path.join(ROOT_DIR, 'ansible')
INVENTORIES_DIR = os.path.join(ANSIBLE_DIR, 'inventories')

ENVIRONMENTS = []

for item in os.listdir(INVENTORIES_DIR):
    if not os.path.isfile(os.path.join(INVENTORIES_DIR, item)):
        ENVIRONMENTS.append(item)

groups = {}
hosts = {}
clusters = {}
systems = []
for env in ENVIRONMENTS:
    hosts[env] = {}
    groups[env] = {}
    clusters[env] = []
    inventory = '%s/%s' % (INVENTORIES_DIR, env)
    hosts_file = os.path.join(inventory, 'hosts')
    with open(hosts_file) as f:
        for line in f:
            if line[0] == '#':
                continue
            if '[' in line and ']' in line:
                if ':' not in line:
                    current_group = line[line.find('[')+1:line.find(']')]
                else:
                    current_group = line[line.find('[')+1:line.find(':')]
                    groups[env][current_group] = []
            elif 'ansible_host' in line:
                hostname, ansible_host = line.split()
                _ ,ansible_host = ansible_host.split('=')
                host = {}
                host['hostname'] = hostname
                host['ansible_host'] = ansible_host            
                hosts[env][current_group] = host
            elif line != '\n' and current_group:
                host = line.strip()
                if host in hosts[env].keys():
                    groups[env][current_group].append(line.strip())
                elif host in groups[env].keys():
                    for machine in groups[env][host]:
                        if machine not in groups[env][current_group]:
                            groups[env][current_group].append(machine)
    clusters[env] = hosts[env].keys() + groups[env].keys()
    for cluster in clusters[env]:
        systems.append('%s:%s' % (cluster, env))

parser = argparse.ArgumentParser(
    description='Make a DISCOS environment. %s' % __doc__,
    formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument(
    'system',
    help='%s, %s, ...' % (systems[-1], systems[-2]))
parser.add_argument(
    '-s',
    '--station',
    choices=STATIONS,
    default=None)
parser.add_argument(
    '-d',
    '--deploy')
parser.add_argument(
    '--sim',
    action='store_true',
    help='simulation mode')

def error(msg, choices=(), name=''):
    if choices:
        choices_msg = 'Allowed values of %s:\n' % name
    else:
        choices_msg = ''
    print('\nERROR: %s%s' % (msg, choices_msg), file=sys.stderr)
    if choices:
        for choice in choices:
            print(' '*2, choice, file=sys.stderr)
    print('\n%s' %  __doc__, file=sys.stderr)
    sys.exit(1)
args = parser.parse_args()

# Check if the system cluster:environment exists
if args.system.count(':') != 1:
    e = ENVIRONMENTS[-1]  # A random environment
    c = clusters[e][-1]  # A random cluster
    msg = ('You must specify an available system.\n'
           'e.g. if the cluster is "%s" '
           'and the environment is "%s",\n'
           'the system is "%s:%s", and the command will be:'
           '\n\n  $ discos-deploy %s:%s.\n\n' % (c, e, c, e, c, e))
    error(msg, choices=systems, name='system')
else:
    cluster_arg, env_arg = args.system.split(':')
    if env_arg in ENVIRONMENTS:
        allowed_clusters = clusters[env_arg]
        c = allowed_clusters[-1]  # A random cluster
        # wrong_cluster:right_env
        if cluster_arg not in allowed_clusters:
            msg = ('Cluster "%s" not found in the "%s" '
                   'environment.\n' % (cluster_arg, env_arg))
            error(msg,
                  allowed_clusters,
                  name='cluster (in %s)' % env_arg)
    else:
        all_clusters = []
        for env in ENVIRONMENTS:
            for cluster in clusters[env]:
                if cluster not in all_clusters:
                    all_clusters.append(cluster)
        # right_cluster:wrong_env
        if cluster_arg in all_clusters:
            msg = ('Environment "%s" not found in %s.\n'
                   'Please use a right cluster:environment combination, like:\n'
                   '%s, %s, %s, ...'
                   % (env_arg, ENVIRONMENTS, systems[0], systems[-1], systems[-2]))
            error(msg)
        # wrong_cluster:wrong_env
        if cluster_arg not in all_clusters:
            error('System "%s:%s" not recognized.\n' % (cluster_arg, env_arg),
                  systems,
                  name='system')

inventory = '%s/inventories/%s' % (ANSIBLE_DIR, env_arg)
playbook = '%s/all.yml'  % ANSIBLE_DIR
os.chdir(ANSIBLE_DIR)

# Create the .ssh directory
ssh_dir = os.path.join(os.environ['HOME'], '.ssh')
if not os.path.exists(ssh_dir):
    os.mkdir(ssh_dir, 0700)

# Generate the public/private key pair (if not present)
key_file = os.path.join(ssh_dir, 'id_rsa')
if not os.path.exists(key_file):
    subprocess.call("ssh-keygen -f %s -t rsa -N '' -q" % key_file, shell=True)
public_key = ''
with open(key_file + '.pub') as pubkey_file:
    public_key = pubkey_file.read().strip()

# Machines to provision in the current process
current_machines = []
if cluster_arg in groups[env_arg]:
    current_machines = groups[env_arg][cluster_arg]
else:
    current_machines.append(cluster_arg)

extra_vars = ''
if env_arg == 'development':
    if bool(args.deploy) ^ bool(args.station):
        error('With `development` environment, both or no '
            + '`--deploy` and `--station` arguments have to be specified.')
    elif args.deploy and args.station:
        if args.station not in STATIONS:
            error('Unknown station `%s`.' % args.station)
        else:
            extra_vars += ' branch=%s station=%s cdb=test' % (args.deploy, args.station)
else:
    if args.station:
        if args.station != env_arg:
            error('With `%s` environment, `--station` argument defaults to `%s`, ' % (env_arg, env_arg)
                + 'you cannot specify a different station.')
    if args.deploy:
        extra_vars += ' branch=%s station=%s cdb=telescope' % (args.deploy, env_arg)

# Initialize a root password for each machine
root_pwds = {}
for machine in current_machines:
    root_pwds[machine] = ''

# Call vagrant to provision the VMs
if env_arg == 'development':
    print('\nCalling Vagrant...\n')
    vagrant_cmd = ['vagrant', 'up'] + current_machines
    if args.sim:
        print(' '.join(vagrant_cmd))
    else:
        code = subprocess.call(' '.join(vagrant_cmd), shell=True)
        if code:
            print('ERROR: some problems running %s' % vagrant_cmd)
            sys.exit(code)
    for key in root_pwds.keys():
        root_pwds[key] = 'vagrant'

# Add the IPs to known_hosts
print('\nUpdating known_hosts...')
known_hosts = os.path.join(ssh_dir, 'known_hosts')
for host_name in current_machines:
    ip = hosts[env_arg][host_name]['ansible_host']
    if not args.sim:
        subprocess.call(
            'ssh-keygen -R %s' % ip,
            shell=True)
        subprocess.call(
            'ssh-keyscan -H %s >> %s' % (ip, known_hosts), shell=True)


def ssh_connect(ssh, ip, password=None):
    try:
        if password:
            ssh.connect(ip, username='root', password=password)
        else:
            ssh.connect(ip, username='root')
        return True
    except paramiko.AuthenticationException:
        return False


ansible_env = os.environ.copy()
manager_sessions = []
console_sessions = []
if not args.sim:
    for machine in current_machines:
        root_pwd = ''
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ip = hosts[env_arg][machine]['ansible_host']
        authenticated = ssh_connect(ssh, ip)
        if not authenticated:
            authenticated = ssh_connect(ssh, ip, root_pwds[machine])
        if not authenticated:
            # Cannot authenticate, it means we have to ask for password
            root_pwd = getpass.getpass(
                'Type the root password for machine %s: ' % machine
            )
            authenticated = ssh_connect(ssh, ip, root_pwd)
        if not authenticated:
            error(
                'Cannot authenticate to machine %s, probable wrong password.'
                % machine
            )
        else:
            root_pwds[machine] = root_pwd
            if 'manager' in machine:
                manager_sessions.append(ssh)
            if 'console' in machine:
                console_sessions.append(ssh)


for ssh in manager_sessions + console_sessions:
    sftp_client = ssh.open_sftp()
    try:
        sftp_client.stat('.ssh')
    except IOError:
        sftp_client.mkdir('.ssh', 0700)
    file_mode = 'r+'
    try:
        sftp_client.stat('.ssh/authorized_keys')
    except IOError:
        file_mode = 'w+'
    remote_file = sftp_client.open('.ssh/authorized_keys', mode=file_mode)
    found = False
    for line in remote_file:
        if public_key in line:
            found = True
    if not found:
        remote_file.write(public_key + '\n')
    remote_file.close()
    sftp_client.chmod('.ssh/authorized_keys', 0600)
    sftp_client.close()


discos_pwd = ''
for ssh in manager_sessions:
    if discos_pwd:
        break
    stdin, stdout, stderr = ssh.exec_command('getent passwd discos')
    stdin.close()

    if not stdout.read().splitlines():
        # User discos not present in a target machine, asking password
        discos_pwd = getpass.getpass('Type the `discos` user desired password: ')
        if not discos_pwd:
            error('A password is required for user `discos`.')
        if discos_pwd != getpass.getpass('Confirm password: '):
            error('Typed password and confirm does not match. Retry.')
        ansible_env['DISCOS_PWD'] = discos_pwd


observer_pwd = ''
for ssh in console_sessions:
    if observer_pwd:
        break
    stdin, stdout, stderr = ssh.exec_command('getent passwd observer')
    stdin.close()

    if not stdout.read().splitlines():
        # User observer not present in a target machine, asking password
        observer_pwd = getpass.getpass('Type the `observer` user desired password: ')
        if not observer_pwd:
            error('A password is required for user `observer`.')
        if observer_pwd != getpass.getpass('Confirm password: '):
            error('Typed password and confirm does not match. Retry.')
        ansible_env['OBSERVER_PWD'] = observer_pwd


# Call ansible
ansible_cmd = [
    'ansible-playbook', playbook,
    '--inventory-file', inventory,
    '--limit', cluster_arg,
    '--extra-vars', "'%s'" % extra_vars.strip(),
]
ansible_cmd = ' '.join(ansible_cmd)

print('\nCalling ansible...\n')
if args.sim:
    print(ansible_cmd)
else:
    subprocess.call(ansible_cmd, env=ansible_env, shell=True)
