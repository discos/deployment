#! /usr/bin/env python
"""Some command line examples:

  $ ./build large:development
  $ ./build large:production
  $ ./build small:development
  $ ./build manager:development
  $ ./build small:development --deploy master --station srt
"""

from __future__ import print_function
import os
import sys
import argparse
import subprocess
import getpass
import paramiko


STATIONS = ('srt', 'medicina', 'noto')
ROOT_DIR = os.path.dirname(os.path.realpath(__file__))
ANSIBLE_DIR = os.path.join(ROOT_DIR, 'ansible')
INVENTORIES_DIR = os.path.join(ANSIBLE_DIR, 'inventories')

ENVIRONMENTS = []

for item in os.listdir(INVENTORIES_DIR):
    if not os.path.isfile(os.path.join(INVENTORIES_DIR, item)):
        ENVIRONMENTS.append(item)


groups = {}
hosts = {}
clusters = {}
systems = []
for env in ENVIRONMENTS:
    hosts[env] = {}
    groups[env] = {}
    clusters[env] = []
    inventory = '%s/%s' % (INVENTORIES_DIR, env)
    hosts_file = os.path.join(inventory, 'hosts')
    with open(hosts_file) as f:
        for line in f:
            if '[' in line and ']' in line:
                if ':' not in line:
                    current_group = line[line.find('[')+1:line.find(']')]
                else:
                    current_group = line[line.find('[')+1:line.find(':')]
                    groups[env][current_group] = []
            elif 'ansible_host' in line:
                hostname, ansible_host = line.split()
                _ ,ansible_host = ansible_host.split('=')
                host = {}
                host['hostname'] = hostname
                host['ansible_host'] = ansible_host            
                hosts[env][current_group] = host
            elif line != '\n' and current_group:
                host = line.strip()
                if host in hosts[env].keys():
                    groups[env][current_group].append(line.strip())
                elif host in groups[env].keys():
                    for machine in groups[env][host]:
                        if machine not in groups[env][current_group]:
                            groups[env][current_group].append(machine)
    clusters[env] = hosts[env].keys() + groups[env].keys()
    for cluster in clusters[env]:
        systems.append('%s:%s' % (cluster, env))


parser = argparse.ArgumentParser(
    description='Make a disco environment. %s' % __doc__,
    formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument(
    'system',
    help='%s, %s, ...' % (systems[-1], systems[-2]))
parser.add_argument(
    '-s',
    '--station',
    choices=STATIONS,
    default=None)
parser.add_argument(
    '-d',
    '--deploy')
parser.add_argument(
    '--sim',
    action='store_true',
    help='simulation mode')


def error(msg, choices=(), name=''):
    if choices:
        choices_msg = 'Allowed values of %s:\n' % name
    else:
        choices_msg = ''
    print('\nERROR: %s%s' % (msg, choices_msg), file=sys.stderr)
    if choices:
        for choice in choices:
            print(' '*2, choice, file=sys.stderr)
    print('\n%s' %  __doc__, file=sys.stderr)
    sys.exit(1)
args = parser.parse_args()


# Check if the system cluster:environment exists
if args.system.count(':') != 1:
    e = ENVIRONMENTS[-1]  # A random environment
    c = clusters[e][-1]  # A random cluster
    msg = ('You must specify an available system.\n'
           'e.g. if the cluster is "%s" '
           'and the environment is "%s",\n'
           'the system is "%s:%s", and the command will be:'
           '\n\n  $ ./build %s:%s.\n\n' % (c, e, c, e, c, e))
    error(msg, choices=systems, name='system')
else:
    cluster_arg, env_arg = args.system.split(':')
    if env_arg in ENVIRONMENTS:
        allowed_clusters = clusters[env_arg]
        c = allowed_clusters[-1]  # A random cluster
        # wrong_cluster:right_env
        if cluster_arg not in allowed_clusters:
            msg = ('Cluster "%s" not found in the "%s" '
                   'environment.\n' % (cluster_arg, env_arg))
            error(msg,
                  allowed_clusters,
                  name='cluster (in %s)' % env_arg)
    else:
        all_clusters = []
        for env in ENVIRONMENTS:
            for cluster in clusters[env]:
                if cluster not in all_clusters:
                    all_clusters.append(cluster)
        # right_cluster:wrong_env
        if cluster_arg in all_clusters:
            msg = ('Environment "%s" not found in %s.\n'
                   'Please use a right cluster:environment combination, like:\n'
                   '%s, %s, %s, ...'
                   % (env_arg, ENVIRONMENTS, systems[0], systems[-1], systems[-2]))
            error(msg)
        # wrong_cluster:wrong_env
        if cluster_arg not in all_clusters:
            error('System "%s:%s" not recognized.\n' % (cluster_arg, env_arg),
                  systems,
                  name='system')


inventory = '%s/inventories/%s' % (ANSIBLE_DIR, env_arg)
playbook = '%s/all.yml'  % ANSIBLE_DIR
os.chdir(ANSIBLE_DIR)


# Create the .ssh directory
ssh_dir = os.path.join(os.environ['HOME'], '.ssh')
if not os.path.exists(ssh_dir):
    os.mkdir(ssh_dir)


# Generate the public/private key pair (if not present)
key_file = os.path.join(ssh_dir, 'id_rsa')
if not os.path.exists(key_file):
    subprocess.call("ssh-keygen -f %s -t rsa -N '' -q" % key_file, shell=True)
public_key = ''
with open(key_file + '.pub') as pubkey_file:
    public_key = pubkey_file.read().strip()


# Machines to provision in the current process
current_machines = []
if cluster_arg in groups[env_arg]:
    current_machines = groups[env_arg][cluster_arg]
else:
    current_machines.append(cluster_arg)


root_pwd = ''
# Call vagrant to provision the VMs
if env_arg == 'development':
    print('\nCalling Vagrant...\n')
    vagrant_cmd = ['vagrant', 'up'] + current_machines
    if args.sim:
        print(' '.join(vagrant_cmd))
    else:
        code = subprocess.call(' '.join(vagrant_cmd), shell=True)
        if code:
            print('ERROR: some problems running %s' % vagrant_cmd)
            sys.exit(code)
    root_pwd = 'vagrant'


# Add the IPs to known_hosts
print('\nUpdating known_hosts...')
known_hosts = os.path.join(ssh_dir, 'known_hosts')
for host_name in current_machines:
    ip = hosts[env_arg][host_name]['ansible_host']
    if not args.sim:
        subprocess.call(
            'ssh-keygen -R %s' % ip,
            shell=True)
        subprocess.call(
            'ssh-keyscan -H %s >> %s' % (ip, known_hosts), shell=True)


extra_vars = ''
discos_pwd = ''
if not args.sim:
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    for machine in current_machines:
        ip = hosts[env_arg][machine]['ansible_host']
        try:
            # Check if we already have passwordless access to the machines
            ssh.connect(ip, username='root')
        except paramiko.AuthenticationException:
            # Cannot authenticate, it means we have to ask for password
            if not root_pwd:
                root_pwd = getpass.getpass('Type the target machines` root password: ')
            try:
                ssh.connect(ip, username='root', password=root_pwd)
                sftp_client = ssh.open_sftp()
                try:
                    sftp_client.stat('.ssh')
                except IOError:
                    sftp_client.mkdir('.ssh')
                file_mode = 'a+'
                try:
                    sftp_client.stat('.ssh/authorized_keys')
                except IOError:
                    file_mode = 'w+'
                remote_file = sftp_client.open('.ssh/authorized_keys', mode=file_mode)
                found = False
                for line in remote_file:
                    if public_key in line:
                        found = True
                if not found:
                    remote_file.write(public_key + '\n')
                remote_file.close()
                sftp_client.close()
            except paramiko.AuthenticationException:
                error('Cannot authenticate, probable wrong password.')
        stdin, stdout, stderr = ssh.exec_command('getent passwd discos')
        stdin.close()

        if not stdout.read().splitlines() and not discos_pwd:
            # User discos not present in target machine, asking password
            discos_pwd = getpass.getpass('Type the `discos` user desired password: ')
            if not discos_pwd:
                error('A password is required for user `discos`.')
            if discos_pwd != getpass.getpass('Confirm password: '):
                error('Typed password and confirm does not match. Retry.')
            extra_vars += ' discos_pwd=%s' % discos_pwd


# Checking if both or no `deploy` and `station` are present
if bool(args.deploy) ^ bool(args.station):
    error('Both or no `--deploy` and `--station` arguments have to be specified.') 
elif args.deploy and args.station:
    if args.station not in STATIONS:
        error('Unknown station `%s`.' % args.station)
    else:
        extra_vars += ' branch=%s station=%s' % (args.deploy, args.station)


extra_vars += ' ansible_user=root'

# Call ansible
ansible_cmd = [
    'ansible-playbook', playbook,
    '--inventory-file', inventory,
    '--limit', cluster_arg,
    '--extra-vars', '"%s"' % extra_vars.strip(),
]

print('\nCalling ansible...\n')
if args.sim:
    print(' '.join(ansible_cmd))
else:
    subprocess.call(' '.join(ansible_cmd), shell=True)
