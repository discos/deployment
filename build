#! /usr/bin/env python
"""Some command line examples:

  $ ./build large:development
  $ ./build large:production
  $ ./build small:development
  $ ./build manager:development
  $ ./build small:development --deploy noto-0.1
  $ ./build small:development --deploy master --station srt
"""

from __future__ import print_function
import os
import sys
import argparse
import itertools
import subprocess


ENVIRONMENTS = ['development', 'production']
STATIONS = ('srt', 'medicina', 'noto')
ROOT_DIR = os.path.dirname(os.path.realpath(__file__))
ANSIBLE_DIR = os.path.join(ROOT_DIR, 'ansible')

systems = []
clusters = {}
all_clusters = []
ips =  {}
for env in ENVIRONMENTS:
    clusters[env] = []
    ips[env] = {}
    inventory = '%s/inventories/%s' % (ANSIBLE_DIR, env)
    hosts_file = os.path.join(inventory, 'hosts')
    with open(hosts_file) as f:
        for line in f:
            line = line.strip()
            if 'ansible_ssh_host' in line:
                first_part, ip = line.split('=')
                node_name, _ = first_part.split()
                ips[env].update({node_name.strip(): ip.strip()})
            if line.startswith('['):
                text = line[line.find('[')+1:line.find(']')]
                host = text.split(':')[0] if ':' in text else text
                if host not in  ('multi', 'local'):
                    all_clusters.append(host)
                    clusters[env].append(host)
                    systems.append('%s:%s' % (host, env))


parser = argparse.ArgumentParser(
    description='Make a disco environment. %s' % __doc__,
    formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument(
    'system',
    help='%s, %s, ...' % (systems[-1], systems[-2]))
parser.add_argument(
    '-s',
    '--station',
    choices=STATIONS,
    default=None)
parser.add_argument(
    '-d',
    '--deploy')
parser.add_argument(
    '--sim',
    action='store_true',
    help='simulation mode')


def error(msg, choices=(), name=''):
    if choices:
        choices_msg = 'Allowed values of %s:\n' % name
    else:
        choices_msg = ''
    print('\nERROR: %s%s' % (msg, choices_msg), file=sys.stderr)
    if choices:
          for choice in choices:
              print(' '*2, choice, file=sys.stderr)
    print('\n%s' %  __doc__, file=sys.stderr)
    sys.exit(1)
args = parser.parse_args()


# The "non station" branches (like master) require the station to be defined
extra_vars = ''
station_branch = False
for station in STATIONS:
    if args.deploy and station.lower() in args.deploy:
        station_branch = True
        break

if not station_branch and args.deploy:
    if not args.station:
        error('--station is required for deploying %s.' % args.deploy)
    else:
        extra_vars = 'station=%s' % args.station
else:
    if args.station:
        error('branch %s does not accept the -s argument.' % args.deploy)


# Check if the system cluster:environment exists
if args.system.count(':') != 1:
    e = ENVIRONMENTS[-1]  # A random environment
    c = clusters[e][-1]  # A random cluster
    msg = ('You must specify an available system.\n'
           'e.g. if the cluster is "%s" '
           'and the environment is "%s",\n'
           'the system is "%s:%s", and the command will be:'
           '\n\n  $ ./build %s:%s.\n\n' % (c, e, c, e, c, e))
    error(msg, choices=systems, name='system')
else:
    cluster_arg, env_arg = args.system.split(':')
    if env_arg in ENVIRONMENTS:
        allowed_clusters = clusters[env_arg]
        c = allowed_clusters[-1]  # A random cluster
        # wrong_cluster:right_env
        if cluster_arg not in allowed_clusters:
            msg = ('Cluster "%s" not found in the "%s" '
                   'environment.\n' % (cluster_arg, env_arg))
            error(msg,
                  allowed_clusters,
                  name='cluster (in %s)' % env_arg)
    else:
        # right_cluster:wrong_env
        if cluster_arg in all_clusters:
            msg = ('Environment "%s" not found in %s.\n'
                   'Please use a right cluster:environment combination, like:\n'
                   '%s, %s, %s, ...'
                   % (env_arg, ENVIRONMENTS, systems[0], systems[-1], systems[-2]))
            error(msg)
        # wrong_cluster:wrong_env
        if cluster_arg not in all_clusters:
            error('System "%s:%s" not recognized.\n' % (cluster_arg, env_arg),
                  systems,
                  name='system')


tags = []
if args.deploy:
    extra_vars += ' branch=%s' % args.deploy
    tags.append('deploy')

inventory = '%s/inventories/%s' % (ANSIBLE_DIR, env_arg)
playbook = '%s/all.yml'  % ANSIBLE_DIR
os.chdir(ANSIBLE_DIR)


def get_host_names(inventory, group, file='hosts'):
    hosts = []
    found = False  # Found the header containing group
    for line in open(os.path.join(inventory, file)):
        line = line.strip()
        header = line[line.find('['):line.find(']')+1]
        if found and not header and line:
            host = line.split()[0]
            hosts.append(host)
        elif found and header:
            break
        elif header and group in header:
            found = True
    return hosts

host_names = get_host_names(inventory, cluster_arg)

# Call vagrant to provision the VMs
print('\nCalling vagrant...\n')
if env_arg == 'development':
    vagrant_cmd = ['vagrant', 'up'] + host_names
    if args.sim:
        print(' '.join(vagrant_cmd))
    else:
        subprocess.call(' '.join(vagrant_cmd), shell=True)


# Add the IPs to known_hosts
print('\nUpdating known_hosts...')
for host_name in host_names:
    ip = ips[env_arg][host_name]
    if not args.sim:
        subprocess.call(
            'ssh-keygen -R %s' % ip,
            shell=True)
        subprocess.call(
            'ssh-keyscan -H %s >> ~/.ssh/known_hosts' % ip,
            shell=True)


# Call ansible
ansible_cmd = [
    'ansible-playbook', playbook,
    '--inventory-file', inventory,
    '--limit', cluster_arg,
    '--extra-vars', '"%s"' % extra_vars,
]
if tags:
    ansible_cmd += ['--tags', ','.join(tags)]
else:
    ansible_cmd += ['--skip-tags', 'deploy']

print('\nCalling ansible...\n')
if args.sim:
    print(' '.join(ansible_cmd))
else:
    subprocess.call(' '.join(ansible_cmd), shell=True)
