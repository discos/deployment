---

- name: Create a temporary directory for the libraries compilation
  file:
    path: "{{ remote_build_path }}"
    state: directory


#################################
# CFITSIO and CCFITS Installation
#################################

- name: Check if {{ cfitsio.file }} is installed
  stat:
    path: "/usr/local/include/fitsio.h"
  register: cfitsio_include


- name: Check if {{ ccfits.file }} is installed
  stat:
    path: "/usr/local/include/CCfits"
  register: ccfits_include


- name: Check if fitsviewer is installed
  stat:
    path: "/usr/local/bin/fv"
  register: fv_binary


- name: Check if the cfitsio sources exist in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ cfitsio.file }}"
  delegate_to: localhost
  run_once: true
  register: cfitsio_sources


- name: Check if the ccfits sources exist in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ ccfits.file }}"
  delegate_to: localhost
  run_once: true
  register: ccfits_sources


- name: Check if the fitsviewer binary exist in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ fv.file }}"
  delegate_to: localhost
  run_once: true
  register: fv_archive


- name: Download {{ cfitsio.file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ cfitsio.file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - cfitsio_include.stat.exists == False
    - cfitsio_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Download {{ ccfits.file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ ccfits.file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - ccfits_include.stat.exists == False
    - ccfits_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Download {{ fv.file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ fv.file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - fv_binary.stat.exists == False
    - fv_archive.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ cfitsio.file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ cfitsio.file }}"
    dest: "{{ remote_build_path }}"
  when: cfitsio_include.stat.exists == False


- name: Install cfitsio
  shell: "{{ item }}"
  with_items:
    - "./configure --prefix=/usr/local"
    - "make"
    - "make install"
  args:
    chdir: "{{ remote_build_path }}/{{ cfitsio.build_dir }}"
  when: cfitsio_include.stat.exists == False


- name: Copy {{ ccfits.file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ ccfits.file }}"
    dest: "{{ remote_build_path }}"
  when: ccfits_include.stat.exists == False


- name: Install CCfits
  shell: "source /etc/profile && {{ item }}"
  with_items:
    - "./configure --prefix=/usr/local"
    - "make"
    - "make install"
  args:
    chdir: "{{ remote_build_path }}/{{ ccfits.build_dir }}"
  when: ccfits_include.stat.exists == False


- name: Export 'PKG_CONFIG_PATH' in order to have access to libcfitsio.so
  lineinfile:
    dest: /etc/profile
    line: 'export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig'


- name: Remove the directory used for the libraries compilation
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ remote_build_path }}/{{ cfitsio.build_dir }}"
    - "{{ remote_build_path }}/{{ ccfits.build_dir }}"


- name: Copy {{ fv.file }} to the remote /usr/local/lib
  unarchive:
    src: "{{ local_repository_path }}/{{ fv.file }}"
    dest: "/usr/local/lib"
  when: fv_binary.stat.exists == False


- lineinfile:
    path: /usr/local/bin/fv
    line: '/usr/local/lib/fv5.4/fv'
    mode: 0755
    state: present
    create: yes
  when: fv_binary.stat.exists == False


#####################
# MODBUS Installation
#####################

- name: Check if {{ modbus.file }} is installed
  stat:
    path: "/usr/local/lib/libmodbus.so"
  register: modbus_lib


- name: Check if the modbus sources exist in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ modbus.file }}"
  delegate_to: localhost
  run_once: true
  register: modbus_sources


- name: Download modbus (if it does not exist in the local repo)
  get_url:
    url: "{{ remote_repository_download_url }}/{{ modbus.file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - modbus_sources.stat.exists == False
    - modbus_lib.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ modbus.file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ modbus.file }}"
    dest: "{{ remote_build_path }}"
  when: modbus_lib.stat.exists == False


- name: Install modbus
  command: "{{ item }}"
  with_items:
    - "./configure --prefix=/usr/local"
    - "make"
    - "make install"
  args:
    chdir: "{{ remote_build_path }}/{{ modbus.build_dir }}"
  when: modbus_lib.stat.exists == False


- name: Remove the directory used for the libraries compilation
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ remote_build_path }}/{{ modbus.build_dir }}"


##############################
# GMOCK and GTEST Installation
##############################

- name: Check if gmock is installed
  stat:
    path: "/usr/local/include/gmock"
  register: gmock_lib


- name: Check if the {{ googletest_file }} exists in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ googletest_file }}"
  delegate_to: localhost
  run_once: true
  register: gmock_sources


- name: Download {{ googletest_file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ googletest_file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - gmock_lib.stat.exists == False
    - gmock_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ googletest_file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ googletest_file }}"
    dest: "{{ remote_build_path }}"
  when: gmock_lib.stat.exists == False


- name: Create a gmock/build directory
  file:
    path: "{{ gmock_build }}/build"
    state: directory
  when: gmock_lib.stat.exists == False


- name: Compile gmock
  shell: "source /etc/profile && {{ item }}"
  with_items:
    - 'cmake ..'
    - 'make'
  args:
    chdir: "{{ gmock_build }}/build"
  when: gmock_lib.stat.exists == False


- file:
    path: "{{ gmock_build }}/build/libgmock.a"
    mode: "a+x"
  when: gmock_lib.stat.exists == False


- file:
    path: "{{ gmock_build }}/build/libgmock_main.a"
    mode: "a+x"
  when: gmock_lib.stat.exists == False


- name: Copy the gmock static libraries to /usr/local/lib
  command: "{{ item.cmd }}"
  with_items:
    - { cmd: 'cp -r gmock /usr/local/include', subdir: 'include' }
    - { cmd: 'cp libgmock.a /usr/local/lib', subdir: 'build' }
    - { cmd: 'cp libgmock_main.a /usr/local/lib', subdir: 'build' }
  args:
    chdir: "{{ gmock_build }}/{{ item.subdir }}"
  when: gmock_lib.stat.exists == False


- name: Check if gtest is installed
  stat:
    path: "/usr/local/include/gtest"
  register: gtest_lib


- name: Create the gtest build directory
  file:
    path: "{{ gtest_build }}/build"
    state: directory
  when: gtest_lib.stat.exists == False


- name: Compile gtest
  shell: "source /etc/profile && {{ item }}"
  args:
    chdir: "{{ gtest_build }}/build"
  with_items:
    - 'cmake ..'
    - 'make'
  when: gtest_lib.stat.exists == False


- file:
    path: "{{ gtest_build }}/build/libgtest.a"
    mode: "a+x"
  when: gtest_lib.stat.exists == False


- file:
    path: "{{ gtest_build }}/build/libgtest_main.a"
    mode: "a+x"
  when: gtest_lib.stat.exists == False


- name: Copy the gtest static libraries to /usr/local
  command: "{{ item.cmd }}"
  args:
    chdir: "{{ gtest_build }}/{{ item.subdir }}"
  with_items:
    - { cmd: 'cp -r gtest /usr/local/include', subdir: 'include' }
    - { cmd: 'cp libgtest.a /usr/local/lib', subdir: 'build' }
    - { cmd: 'cp libgtest_main.a /usr/local/lib', subdir: 'build' }
  when: gtest_lib.stat.exists == False


- name: Remove the directory used for the libraries compilation
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ remote_build_path }}/{{ googletest_build_dir }}"


#####
# f2c
#####

- name: Check if f2c is installed
  stat:
    path: "/usr/local/include/f2c.h"
  register: f2c_header


- name: Check if the f2c sources exist in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ f2c.file }}"
  delegate_to: localhost
  run_once: true
  register: f2c_sources


- name: Download f2c
  get_url:
    url: "{{ remote_repository_download_url }}/{{ f2c.file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - f2c_header.stat.exists == False
    - f2c_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy f2c to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ f2c.file }}"
    dest: "{{ remote_build_path }}"
  when: f2c_header.stat.exists == False


- name: Install f2c
  command: "{{ item }}"
  with_items:
    - "cp makefile.u Makefile"
    - "make"
    - "cp f2c.h /usr/local/include"
    - "cp f2c /usr/local/bin"
  args:
    chdir: "{{ remote_build_path }}/f2c-master/src"
  when: f2c_header.stat.exists == False


- name: Remove the directory used for the libraries compilation
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ remote_build_path }}/f2c-master"


#######################
# QT AND PYQT LIBRARIES
#######################

- name: Increment the process stack size in order to compile SRT AS GUI
  pam_limits:
    domain: "{{ user.name }}"
    limit_type: '-'
    limit_item: stack
    value: '65532'


- name: Verify the sip library is not installed
  yum:
    name: sip
    state: absent


- name: Check if sip is installed
  stat:
    path: "/alma/{{ acs_tag }}/pyenv/shims/sip"
  register: sip_library


- name: Check if the {{ sip_file }}  exists in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ sip_file }}"
  delegate_to: localhost
  run_once: true
  register: sip_sources


- name: Download {{ sip_file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ sip_file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - sip_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ sip_file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ sip_file }}"
    dest: "{{ remote_build_path }}"
    owner: "{{ user.name }}"
    group: "{{ user.group }}"
  when: sip_library.stat.exists == False


- name: Install sip
  command: "{{ item }}"
  with_items:
    - "python configure.py"
    - "make"
    - "make install"
    - "pyenv rehash"
  become: true
  become_user: "{{ user.name }}"
  become_flags: "-i"
  args:
    chdir: "{{ remote_build_path }}/{{ sip_build_dir }}"
  when: sip_library.stat.exists == False


- name: Verify the PyQt4 library is not installed
  yum:
    name: PyQt4
    state: absent


- name: Check if PyQt is installed
  stat:
    path: "/alma/{{ acs_tag }}/pyenv/shims/pyuic4"
  register: pyqt_library


- name: Check if the {{ pyqt_file }}  exists in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ pyqt_file }}"
  delegate_to: localhost
  run_once: true
  register: pyqt_sources


- name: Download {{ pyqt_file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ pyqt_file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - pyqt_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ pyqt_file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ pyqt_file }}"
    dest: "{{ remote_build_path }}"
    owner: "{{ user.name }}"
    group: "{{ user.group }}"
  when: pyqt_library.stat.exists == False


- name: Configure PyQt
  shell: "python configure.py --confirm-license --qmake `which qmake`"
  become: true
  become_user: "{{ user.name }}"
  become_flags: "-i"
  args:
    chdir: "{{ remote_build_path }}/{{ pyqt_build_dir }}"
  when: pyqt_library.stat.exists == False


- name: Remove PrintCurrentPage from source files
  lineinfile:
    dest: "{{ item }}"
    state: absent
    regexp: "^.*PrintCurrentPage.*$"
  with_items:
    - "{{ remote_build_path }}/{{ pyqt_build_dir }}/QtGui/sipAPIQtGui.h"
    - "{{ remote_build_path }}/{{ pyqt_build_dir }}/QtGui/sipQtGuiQAbstractPrintDialog.cpp"
    - "{{ remote_build_path }}/{{ pyqt_build_dir }}/sip/QtGui/qabstractprintdialog.sip"
  become: true
  become_user: "{{ user.name }}"
  when: pyqt_library.stat.exists == False


- name: Install PyQt
  command: "{{ item }}"
  with_items:
    - "make"
    - "make install"
    - "pyenv rehash"
  become: true
  become_user: "{{ user.name }}"
  become_flags: "-i"
  args:
    chdir: "{{ remote_build_path }}/{{ pyqt_build_dir }}"
  when: pyqt_library.stat.exists == False


- name: Check if PyQtQwt is installed
  stat:
    path: "/alma/{{ acs_tag }}/pyenv/versions/3.6.9/share/sip/PyQt4/Qwt"
  register: pyqtqwt_library


- name: Check if the {{ pyqtqwt_file }}  exists in the local repository
  stat:
    path: "{{ local_repository_path }}/{{ pyqtqwt_file }}"
  delegate_to: localhost
  run_once: true
  register: pyqtqwt_sources


- name: Download {{ pyqtqwt_file }}
  get_url:
    url: "{{ remote_repository_download_url }}/{{ pyqtqwt_file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - pyqtqwt_sources.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Copy {{ pyqtqwt_file }} to the remote {{ remote_build_path }}
  unarchive:
    src: "{{ local_repository_path }}/{{ pyqtqwt_file }}"
    dest: "{{ remote_build_path }}"
    owner: "{{ user.name }}"
    group: "{{ user.group }}"
  when: pyqtqwt_library.stat.exists == False


- name: Copy include files
  copy:
    src: "/usr/include/qwt"
    dest: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/header/"
    force: True
    owner: "{{ user.name }}"
    remote_src: True
  when: pyqtqwt_library.stat.exists == False


- name: Replace include files
  copy:
    src: "{{ item }}"
    dest: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/header/qwt/"
    force: True
    owner: "{{ user.name }}"
    remote_src: True
  with_items:
    - "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/header/qwt_series_data.h"
    - "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/header/qwt_series_store.h"
  when: pyqtqwt_library.stat.exists == False


- name: Patch Qwt_Qt4.sip
  replace:
    dest: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/sip/Qwt_Qt4.sip"
    regexp: "{{ item.regexp }}"
    replace: "{{ item.replace }}"
  with_items:
    - { regexp: "//typedef unsigned long size_t;", replace: "typedef unsigned long size_t;" }
    - { regexp: "%Include qwt_plot_zoomer.sip", replace: "//%Include qwt_plot_zoomer.sip" }
    - { regexp: "%Include qwt_plot_spectrocurve.sip", replace: "//%Include qwt_plot_spectrocurve.sip" }
    - { regexp: "%Include qwt_plot_tradingcurve.sip", replace: "//%Include qwt_plot_tradingcurve.sip" }
  when: pyqtqwt_library.stat.exists == False


- name: Patch qwt_plot_renderer.sip
  replace:
    dest: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/sip/qwt_plot_renderer.sip"
    regexp: "class QPrinter;"
    replace: "//class QPrinter;"
  when: pyqtqwt_library.stat.exists == False


- name: Configure PyQtQwt
  command: "{{ item }}"
  with_items:
    - "python configure.py --pyqt=PyQt4 --qwt-incdir=header/qwt/"
  become: true
  become_user: "{{ user.name }}"
  become_flags: "-i"
  args:
    chdir: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}"
  when: pyqtqwt_library.stat.exists == False


- name: Patch Makefile
  replace:
    dest: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}/Qwt/Makefile"
    regexp: "-I. -I/usr/include/QtCore"
    replace: "-I. -I/usr/include/Qt -I/usr/include/QtCore"
  when: pyqtqwt_library.stat.exists == False


- name: Build and install PyQtQwt
  command: "{{ item.command }}"
  become: "{{ item.become }}"
  become_user: "{{ user.name }}"
  become_flags: "-i"
  with_items:
    - { become: "true", command: "make" }
    - { become: "true", command: "make install_subtargets" }
    - { become: "true", command: "make install_pep484_stubs" }
    - { become: "false", command: "make install_api" }
    - { become: "true", command: "make install_distinfo" }
    - { become: "true", command: "pyenv rehash" }
  args:
    chdir: "{{ remote_build_path }}/{{ pyqtqwt_build_dir }}"
  when: pyqtqwt_library.stat.exists == False


- name: Remove the temporary directory used for libraries compilation
  file:
    path: "{{ remote_build_path }}"
    state: absent


#################
# PYTHON PACKAGES
#################

- name: Manually get rid of cryptography package since it breaks pip functionality
  file:
    path: "/alma/{{ acs_tag }}/pyenv/versions/3.9.4/lib/python3.9/site-packages/cryptography"
    state: absent


- name: Install some third-party Python packages
  command: "{{ item }}"
  with_items:
    - "pip uninstall -y pyopenssl"
    - "pip install pyopenssl"
    - "pip install cryptography"
    - "pip install pbr"
    - "pip install mock==1.1.1"
    - "pip install jinja2"
    - "pip install subprocess32"
    - "pip install d2to1"
    - "pip install stsci.distutils"
    - "pip install pyfits"
  become: true
  become_user: "{{ user.name }}"
  become_flags: "-i"


#########################
# COMPONENTS REQUIREMENTS
#########################

- name: Increment the maximum number of user processes in order to run the AS
  pam_limits:
    domain: "{{ user.name }}"
    limit_type: '-'
    limit_item: nproc
    value: '63266'


############
# SlaLibrary
############

- name: Check if the SlaLibrary is installed
  stat:
    path: "/{{ discos_sw_dir }}/SlaLibrary"
  register: slalibrary_present


- name: Download the SlaLibrary archive
  get_url:
    url: "{{ remote_repository_download_url }}/{{ slalibrary_file }}"
    dest: "{{ local_repository_path }}"
    headers:
      Authorization: "token {{ repository_token }}"
  when:
    - slalibrary_present.stat.exists == False
  delegate_to: localhost
  run_once: true


- name: Create the SlaLibrary directory under {{ discos_sw_dir }}
  file:
    path: "/{{ discos_sw_dir }}/SlaLibrary"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.group }}"
    mode: 0755
  when:
    - slalibrary_present.stat.exists == False


- name: Extract the SlaLibrary archive to the remote
  unarchive:
    src: "{{ local_repository_path }}/{{ slalibrary_file }}"
    dest: "/{{ discos_sw_dir }}/SlaLibrary/"
    owner: "{{ user.name }}"
    group: "{{ user.group }}"
  when:
    - slalibrary_present.stat.exists == False
